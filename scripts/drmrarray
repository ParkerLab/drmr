#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# drmrarray: A tool for submitting pipeline scripts to distributed
# resource managers in array jobs.
#
# Copyright 2015 The Parker Lab at the University of Michigan
#
# Licensed under Version 3 of the GPL or any later version
#


from __future__ import print_function

import argparse
import logging
import os
import sys
import textwrap

import drmr
import drmr.script


HELP = """

    Supported resource managers are:

{resource_managers}

    drmr will read configuration from your ~/.drmrc, which must be
    valid JSON. You can specify your resource manager and default
    values for any job parameters listed below.

    Directives
    ==========

    Your script can specify job parameters in special comments starting
    with "drmr:job".

    # drmr:job

      You can customize the following job parameters:

{job_directives}

      Whatever you specify will apply to all jobs after the directive.

      To revert to default parameters, use:

      # drmr:job default

      To request 4 CPUs, 8GB of memory per processor, and a
      limit of 12 hours of execution time on one node:

      # drmr:job nodes=1 processors=4 processor_memory=8000 time_limit=12:00:00
""".format(**{
    'job_directives': '\n'.join('      {}: {}'.format(*i) for i in drmr.script.JOB_DIRECTIVES.items()),
    'resource_managers': '\n'.join('      {}'.format(name) for name in drmr.RESOURCE_MANAGERS.keys()),
})


def parse_arguments():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='Submit a drmr script to a distributed resource manager as a job array.',
        epilog=textwrap.dedent(HELP)
    )

    parser.add_argument('-a', '--account', dest='account', help='The account to be billed for the jobs.')
    parser.add_argument('-d', '--destination', dest='destination', help='The queue/partition in which to run the jobs.')
    parser.add_argument('--debug', dest='debug', action='store_true', help='Turn on debug-level logging.')
    parser.add_argument('-f', '--finish-jobs', dest='finish_jobs', action='store_true', help='If specified, two extra jobs will be queued after the main array, to indicate success and completion.')
    parser.add_argument('-j', '--job-name', dest='job_name', required=True, help='The job name.')
    parser.add_argument('-m', '--mail-at-finish', dest='mail_at_finish', action='store_true', help='If specified, mail will be sent when all jobs are finished.')
    parser.add_argument('-w', '--wait-list', dest='wait_list', help="A colon-separated list of job IDs that must complete before any of this script's jobs are started.")
    parser.add_argument('input', help='The file containing commands to submit. Use "-" for stdin.')

    return parser.parse_args()


def create_jobs(resource_manager, template_data, script, wait_list=[]):
    job_name = template_data['job_name']
    job_directives = {}

    job_data = template_data.copy()
    job_data.update({
        'job_name': job_name
    })

    commands = []
    for i, line in enumerate(script, 1):
        directive, args = drmr.script.parse_directive(line)
        if directive:
            if commands:
                raise SyntaxError('Any drmr directives must appear before the first command in the script')
            if directive == 'job' and args:
                job_directives = dict([a.split('=', 1) for a in args.split()])
                job_data.update(job_directives)
        else:
            command_data = {
                'command': line,
                'index': len(commands) + 1
            }
            commands.append(resource_manager.make_array_command(command_data))

    command_count = max(len(commands), 1)
    job_data.update({
        'array_controls': {
            'array_index_min': 1,
            'array_index_max': command_count,
            'array_concurrent_jobs': command_count
        },
        'command': '\n'.join(commands)
    })

    job_file = resource_manager.write_job_file(job_data)
    job_id = resource_manager.submit(job_file)

    return job_id


if __name__ == '__main__':

    args = parse_arguments()

    if args.debug:
        logging.basicConfig(level=logging.DEBUG)

    try:
        config = drmr.load_configuration({'account': args.account, 'destination': args.destination})
    except drmr.ConfigurationError as e:
        print(e, file=sys.stderr)
        sys.exit(1)

    if 'resource_manager' not in config:
        print('Please specify your resource manager in your drmr configuration file.', file=sys.stderr)
        sys.exit(1)

    resource_manager = drmr.get_resource_manager(config['resource_manager'])

    template_data = {
        'account': config['account'],
        'destination': config['destination'],
        'job_name': args.job_name,
        'working_directory': os.path.abspath(os.getcwd()),
    }

    input_file = args.input == '-' and sys.stdin or open(args.input)
    script = [line for line in drmr.script.parse_script(input_file.read()) if not drmr.script.is_boring(line)]

    wait_list = args.wait_list and args.wait_list.split(':') or []

    try:
        completion_job_id = create_jobs(resource_manager, template_data, script, wait_list)
        if args.finish_jobs or args.mail_at_finish:
            completion_job_id = resource_manager.submit_completion_jobs(template_data, [completion_job_id], mail_at_finish=args.mail_at_finish)
        print(completion_job_id)
    except drmr.SubmissionError as e:
        print('\nYour script could not be submitted.')
        print("Command '%s' returned %s." % (' '.join(e.cmd), e.returncode))
        print("Command output was:\n\n%s\n" % e.output)
        sys.exit(1)
